{
    "problem": {
        "id": "0002",
        "slug": "bubbleSort",
        "title": "氣泡排序算法",
        "content": {
            "description": "給定一個整數數組 `nums`，請你使用 <b>氣泡排序算法</b> 將數組按 <b>升序排列</b>。氣泡排序是一種簡單的排序算法，它重複地遍歷要排序的數列，一次比較兩個元素，如果它們的順序錯誤就交換它們。\n\n你需要實現氣泡排序算法，並計算排序過程中的總交換次數。",
            
            "input_format": "一個整數 n，表示數組的長度\n一個數組 nums，表示長度為n個整數的數組，表示需要排序的數組元素\n\n範例輸入：\nn = 6\nnums = [64, 34, 25, 12, 22, 11, 90]",
            
            "output_format": "輸出一個數組：\n第一個元素表示總交換次數\n第二個元素表示已排序的數組\n\n範例輸出：\n[15, [11, 12, 22, 25, 34, 64, 90]",
            
            "constraints": [
                "1 ≤ n ≤ 1000",
                "-10⁴ ≤ nums[i] ≤ 10⁴",
                "數組可能包含重複元素",
                "必須使用氣泡排序算法",
                "需要計算並輸出總交換次數"
            ],

            "sampleCode": "def bubbleSort(n: int, nums: list[int]):",

            "execuationCode": "bubbleSort",
            
            "examples": [
                {
                    "input": "n=6\nnums=[64, 34, 25, 12, 22, 11, 90]",
                    "output": "[15, [11, 12, 22, 25, 34, 64, 90]",
                    "explanation": "氣泡排序過程：\n第1輪：[34, 25, 12, 22, 11, 64, 90] (5次交換)\n第2輪：[25, 12, 22, 11, 34, 64, 90] (4次交換)\n第3輪：[12, 22, 11, 25, 34, 64, 90] (3次交換)\n第4輪：[12, 11, 22, 25, 34, 64, 90] (2次交換)\n第5輪：[11, 12, 22, 25, 34, 64, 90] (1次交換)\n總交換次數：5+4+3+2+1 = 15"
                },
                {
                    "input": "n=5\nnums=[5, 1, 4, 2, 8]",
                    "output": "[5, [1, 2, 4, 5, 8]",
                    "explanation": "氣泡排序過程（優化版）：\n第1輪：[1, 4, 2, 5, 8] (3次交換)\n第2輪：[1, 2, 4, 5, 8] (1次交換)\n第3輪：[1, 2, 4, 5, 8] (0次交換，提前結束)\n總交換次數：3+1 = 4"
                },
                {
                    "input": "n=1\nnums=[42]",
                    "output": "[0, [42]",
                    "explanation": "數組只有一個元素，已經是排序狀態，無需交換"
                },
                {
                    "input": "n=4\nnums=[4, 3, 2, 1]",
                    "output": "[6, [1, 2, 3, 4]",
                    "explanation": "最壞情況（完全逆序）：\n第1輪：[3, 2, 1, 4] (3次交換)\n第2輪：[2, 1, 3, 4] (2次交換)\n第3輪：[1, 2, 3, 4] (1次交換)\n總交換次數：3+2+1 = 6"
                },
                {
                    "input": "n=5\nnums=[1, 2, 3, 4, 5]",
                    "output": "[0, [1, 2, 3, 4, 5]",
                    "explanation": "最佳情況（已經排序）：第一輪遍歷後發現沒有交換，算法提前結束"
                }
            ],
            
            "notes": [
                "<b>氣泡排序算法步驟</b>：\n1. 從數組的第一個元素開始，比較相鄰的兩個元素\n2. 如果第一個元素比第二個大，就交換它們的位置\n3. 對每一對相鄰元素做同樣的工作，從開始第一對到結尾的最後一對\n4. 完成一輪後，最大的元素會「冒泡」到數組的末尾\n5. 重複上述步驟，每次忽略最後一個已經排序的元素\n6. 如果在某一輪中沒有發生任何交換，說明數組已經排序完成，可以提前結束",
                
                "<b>優化技巧</b>：\n1. 設定一個標誌變量來記錄本輪是否發生交換\n2. 如果某一輪沒有發生交換，說明數組已經排序完成，可以提前退出循環\n3. 每次外層循環後，最後一個元素已經是最大的，所以內層循環的範圍可以逐漸減小",
                
                "<b>時間與空間複雜度分析</b>：\n- 最壞情況時間複雜度：O(n²) - 當數組完全逆序時\n- 最佳情況時間複雜度：O(n) - 當數組已經排序時（優化版本）\n- 平均情況時間複雜度：O(n²)\n- 空間複雜度：O(1) - 只需要常數級別的額外空間（原地排序）",
                
                "<b>算法實現代碼範例</b>：\n```python\ndef bubble_sort(nums):\n    n = len(nums)\n    total_swaps = 0\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n                total_swaps += 1\n                swapped = True\n        if not swapped:\n            break\n    return nums, total_swaps\n```",
                
                "<b>常見錯誤</b>：\n1. 忘記處理邊界條件（空數組或單元素數組）\n2. 內層循環的範圍設定錯誤\n3. 沒有實現提前結束的優化\n4. 交換計數不準確",
                
                "<b>變形題目思考</b>：\n1. 如何修改算法實現降序排序？\n2. 如何實現雙向氣泡排序（雞尾酒排序）？\n3. 氣泡排序是穩定的排序算法嗎？為什麼？\n4. 如果只需要找到第 k 小的元素，是否需要完整排序？"
            ]
        }
    }
}