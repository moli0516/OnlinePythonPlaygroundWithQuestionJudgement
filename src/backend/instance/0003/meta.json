{
    "problem": {
        "id": "0003",
        "slug": "Remove n boxes",
        "title": "移除箱子",
        "content": {
            "description": "給定一個 <b>堆叠</b>  `boxes` 包含 `k` 個箱子，和一個整數 `n`，堆叠底下有 `n` 個箱子是腐爛的。\n<b>rev(a, b)</b> 是一個可以把堆叠 `a` 的元素轉移至堆叠 `b` 倒轉順序的步驟。\n請移除所有腐爛的箱子，返回結果堆叠",
    
            "input_format": "boxes 表示<b>堆叠。</b>\nn 表示腐爛的箱子數量。\n\n範例輸入：\nboxes = [1, 2, 4, 10, 9], n = 3",
            
            "output_format": "輸出一個移除腐爛箱子後的堆叠：\n\n範例輸出：\n[10, 9]",
            
            "constraints": [
            "0 ≤ n ≤ length of boxes",
            "-10⁴ ≤ boxes[i] ≤ 10⁴",
            "0 ≤ length of boxes ≤ 10⁴"
            ],

            "sampleCode": "# definition of stack.\n# class Stack:\n#     def __init__(self, nums = None):\n#         self.nums = nums\n#     def pop(self):\n#         return the top item and remove it\n#     def push(self, val):\n#         add val on the top of the stack\n\ndef removeBoxes(boxes: Optional[Stack], n: int):",

            "execuationCode": "removeBoxes",
            
            "examples": [
                {
                    "input": "boxes = [1, 2, 4, 10, 9], n = 3",
                    "output": "[10, 9]",
                    "explanation": ""
                },
                {
                    "input": "boxes = [], n = 0",
                    "output": "[]",
                    "explanation": ""
                },
                {
                    "input": "boxes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], n = 10",
                    "output": "[]",
                    "explanation": ""
                }
            ],
            
            "notes": [
            "<b>二分查找算法步驟</b>：\n1. 初始化左右指針 left=0, right=n-1\n2. 當 left ≤ right 時循環：\n   a. 計算中間索引 mid = left + (right - left) // 2\n   b. 如果 nums[mid] == target，返回 mid\n   c. 如果 nums[mid] < target，則 left = mid + 1\n   d. 如果 nums[mid] > target，則 right = mid - 1\n3. 循環結束後返回 -1",
            
            "<b>關鍵要點</b>：\n- 計算 mid 時使用 `left + (right - left) // 2` 而不是 `(left + right) // 2`，避免整數溢出\n- 循環條件是 `left ≤ right` 而不是 `left < right`，確保檢查所有元素\n- 每次比較後要排除中間元素，所以更新 left 或 right 時要加減 1",
            
            "<b>時間與空間複雜度分析</b>：\n- 時間複雜度：O(log n)，每次迭代將搜索範圍減半\n- 空間複雜度：O(1)，只使用常數額外空間",
            
            "<b>常見錯誤</b>：\n1. 忘記處理空數組的情況\n2. 在更新 left 或 right 時忘記加減 1，導致無限循環\n3. 使用錯誤的循環條件，可能漏掉邊界元素\n4. 整數溢出問題（在大數組中）",
            
            "<b>變形題目思考</b>：\n1. 如果數組中允許重複元素，如何找到第一個出現的位置？\n2. 如果數組是降序排列的，算法該如何調整？\n3. 如果不知道數組是否排序，該如何處理？"
            ]
        }
    }
}